# -------------------------------------------------------------------------
# 1. Main Generic Function
# -------------------------------------------------------------------------

#' OASIS Calcium Deconvolution (Main Interface)
#'
#' The main entry point for the OASIS calcium deconvolution algorithm.
#' This function dispatches the appropriate method based on the input data type 
#' (raw vector, matrix, or simulation object).
#'
#' @param x Input data. Can be:
#'   \itemize{
#'     \item A numeric vector (single neuron fluorescence trace).
#'     \item A numeric matrix (N neurons x T frames).
#'     \item A \code{calcium_sim} object generated by \code{\link{generate_data}}.
#'   }
#' @param ... Arguments passed to the specific methods (see \code{\link{oasis.default}}).
#'
#' @return An object of class \code{"oasis_fit"} (for single neuron) or 
#'   \code{"oasis_multi_fit"} (for multiple neurons). 
#'   See \code{\link{oasis.default}} for structure details.
#'
#' @seealso \code{\link{oasis.default}} for parameter details, 
#'   \code{\link{oasis.calcium_sim}} for simulation handling, 
#'   and \code{\link{generate_data}} for creating synthetic data.
#' 
#' @examples
#' # Example 1: Simulation and Deconvolution (Single Neuron)
#' # -------------------------------------------------------
#' # 1. Generate synthetic data (N=1)
#' sim_data <- generate_data(N = 1, seed = 123)
#' 
#' # 2. Run OASIS (automatic parameter estimation)
#' fit <- oasis(sim_data)
#' 
#' # 3. Check parameters and performance
#' print(fit)
#' 
#' # Example 2: Working with Raw Vectors
#' # -----------------------------------
#' # Extract the raw fluorescence vector
#' y_raw <- sim_data$Y
#' 
#' # Run OASIS on the vector directly
#' fit_vec <- oasis(y_raw)
#' print(fit_vec)
#' 
#' # Example 3: Batch Processing (Multi-Neuron)
#' # ------------------------------------------
#' sim_multi <- generate_data(N = 5, nf = 300, seed = 42)
#' fit_multi <- oasis(sim_multi)
#' print(fit_multi)
#' 
#' @export
oasis <- function(x, ...) {
  UseMethod("oasis")
}


#' OASIS Deconvolution for Raw Data (Vector/Matrix)
#'
#' The specific implementation of OASIS for processing raw numeric data.
#' It handles parameter estimation (if \code{g} or \code{lam} are NULL) and 
#' executes the deconvolution.
#'
#' @param x Numeric vector or matrix. The fluorescence data.
#' @param g Numeric scalar (optional). The AR(1) decay parameter (0 < g < 1).
#'   If \code{NULL} (default), it is estimated automatically from the 
#'   autocorrelation of the data using \code{\link{GetDecay}}.
#' @param lam Numeric scalar (optional). The sparsity penalty parameter.
#'   If \code{NULL} (default), it is estimated heuristically based on the noise 
#'   level (\eqn{\lambda \approx 2 \cdot \sigma}) or iteratively.
#' @param s_min Numeric scalar. Minimum spike magnitude constraint.
#' @param optimize Logical. If \code{TRUE}, uses an iterative optimization 
#'   on decimated data to estimate \code{g} and \code{lam}. 
#'   Ignored if \code{g} and \code{lam} are provided manually.
#' @param ... Additional arguments ignored.
#'
#' @return An object of class \code{"oasis_fit"} containing:
#' \describe{
#'   \item{c}{The denoised calcium concentration trace.}
#'   \item{s}{The inferred spike train.}
#'   \item{pars}{A list of parameters used (g, lam, sn, etc.).}
#'   }
#'   
#' @examples
#' # Prepare data
#' dat <- generate_data(N = 1, seed = 123)
#' y_vec <- dat$Y # Extract raw vector
#' 
#' # Call the default method explicitly (or via generic)
#' fit <- oasis(y_vec, g = 0.95)
#' print(fit)
#' 
#' fit_opt <- oasis(y_vec, optimize = TRUE)
#' print(fit_opt)
#'
#' @seealso \code{\link{oasis}}
#' @export
oasis.default <- function(x, g = NULL, lam = NULL, s_min = 0, optimize = FALSE, ...) {
  
  if(is.matrix(x) && nrow(x) == 1)
    x <- as.vector(x)
  
  is_matrix_input <- is.matrix(x)
  
  if (is_matrix_input) {
    row_vars <- apply(x, 1, var)
    best_idx <- which.max(row_vars)
    y_rep <- as.numeric(x[best_idx, ])
  } else {
    y_rep <- as.numeric(x)
  }
  
  final_g <- g
  final_lam <- lam
  
  g_source <- if(is.null(g)) "unknown" else "user-provided"
  lam_source <- if(is.null(lam)) "unknown" else "user-provided"
  
  if (is.null(final_g) || is.null(final_lam)) {
    
    if (optimize) {
      opt_params <- estimate_params_iterative(y_rep, decimate = 10)
      
      if (is.null(final_g)) {
        final_g <- opt_params$g
        g_source <- if(is_matrix_input) "optimized (global/decimated)" else "optimized (decimated)"
      }
      
      if (is.null(final_lam)) {
        final_lam <- opt_params$lam
        lam_source <- if(is_matrix_input) "optimized (global/RSS)" else "optimized (RSS constraint)"
      }
      
      if(is_matrix_input) {
        message(sprintf("OASIS Global Params (from neuron %d): g=%.4f, lam=%.4f", best_idx, final_g, final_lam))
      }
      
    }
    else{
      est_sn <- GetSn(y_rep) 
      
      if (is.null(final_g)) {
        final_g <- GetDecay(y_rep, sn = est_sn)
        g_source <- if(is_matrix_input) "estimated (global/autocorr)" else "estimated (autocorr)"
      }
      
      if (is.null(final_lam)) {
        final_lam <- 2.0 * est_sn
        lam_source <- if(is_matrix_input) "heuristic (global/2*sn)" else "heuristic (2*sn)"
      }
    }
  }
  
  construct_result <- function(y_vec) {
    fit <- oasis_ar1(y_vec, g = final_g, lam = final_lam, s_min = s_min)
    current_sn <- GetSn(y_vec)
    res <- list(
      c = fit$c,
      s = fit$s,
      pars = list(
        g = final_g, 
        lam = final_lam, 
        s_min = s_min,
        sn = current_sn,      
        g_source = g_source,   
        lam_source = lam_source 
      )
    )
    class(res) <- c("oasis_fit", "list")
    return(res)
  }
  
  if (is_matrix_input) {
    res_list <- apply(x, 1, construct_result, simplify = FALSE)
    class(res_list) <- c("oasis_multi_fit", "list")
    return(res_list)
    
  } else {
    return(construct_result(as.numeric(x)))
  }
}


# -------------------------------------------------------------------------
# 3. Simulation Method (Wrapper)
# -------------------------------------------------------------------------

#' OASIS Deconvolution for Simulation Data
#'
#' A wrapper method specifically for \code{calcium_sim} objects. 
#' It automatically extracts the noisy fluorescence (\code{Y}) for deconvolution
#' and compares the result against the ground truth (\code{c}, \code{s}) to 
#' calculate performance metrics.
#'
#' @param x A \code{calcium_sim} object generated by \code{\link{generate_data}}.
#' @param ... Additional arguments passed to \code{\link{oasis.default}} 
#'   (e.g., \code{g}, \code{lam}).
#'
#' @return An \code{"oasis_fit"} object (or list of them) with an added
#'   \code{$performance} component containing:
#'   \describe{
#'   \item{cor_c}{Correlation between estimated and true calcium trace.}
#'   \item{rms_c}{Root Mean Square Error of the calcium trace.}
#'   \item{cor_s}{Correlation between estimated and true spike train.}
#'  }
#'
#' @examples
#' # 1. Generate simulation object
#' sim <- generate_data(N = 1, seed = 42)
#' 
#' # 2. Run wrapper (calculates performance metrics automatically)
#' fit <- oasis(sim)
#' print(fit)
#'   
#' @seealso \code{\link{oasis}}, \code{\link{generate_data}}
#' @export
oasis.calcium_sim <- function(x, ...){
  
  y <- x$Y
  
  fit <- oasis(y, ...)
  
  true_c <- x$c
  true_s <- x$s
  
  calc_metrics <- function(est_c, est_s, true_c_vec, true_s_vec){
    list(
      cor_c = cor(est_c, true_c_vec),
      rms_c = sqrt(mean((est_c - true_c_vec)^2)),
      cor_s = cor(est_s, true_s_vec)
    )
  }
  
  if (inherits(fit, "oasis_multi_fit")) {
    for (i in seq_along(fit)) {
      metrics <- calc_metrics(fit[[i]]$c, fit[[i]]$s, true_c[i, ], true_s[i, ])
      fit[[i]]$performance <- metrics
    }
  }
  else{
    truth_c_vec <- if(is.matrix(true_c)) true_c[1,] else true_c
    truth_s_vec <- if(is.matrix(true_s)) true_s[1,] else true_s
    
    metrics <- calc_metrics(fit$c, fit$s, truth_c_vec, truth_s_vec)
    fit$performance <- metrics
  }
  
  return(fit)
}


# -------------------------------------------------------------------------
# Utilities: Print Methods
# -------------------------------------------------------------------------

#' @export
print.oasis_fit <- function(x, ...) {
  cat("OASIS AR(1) Single-Neuron Fit Object\n")
  cat("----------------------\n")
  cat(sprintf("Parameters:\n"))
  cat(sprintf("  g   : %.4f (%s)\n", x$pars$g, x$pars$g_source))
  cat(sprintf("  lam : %.4f (%s)\n", x$pars$lam, x$pars$lam_source))
  cat(sprintf("  sn  : %.4f (estimated)\n", x$pars$sn))
  
  if (!is.null(x$performance)) {
    cat("\nPerformance (vs Truth):\n")
    cat(sprintf("  Corr(C): %.4f\n", x$performance$cor_c))
    cat(sprintf("  RMSE(C): %.4f\n", x$performance$rms_c))
    cat(sprintf("  Corr(S): %.4f\n", x$performance$cor_s))
  }
  
  cat("\nAccess components via $c (denoised) and $s (spikes).\n")
  invisible(x)
}

#' @export
print.oasis_multi_fit <- function(x, ...) {
  n_neurons <- length(x)
  if (n_neurons == 0) {
    cat("Empty OASIS Multi-Fit Object\n")
    return(invisible(x))
  }
  
  n_frames <- length(x[[1]]$c)
  
  all_g   <- sapply(x, function(fit) fit$pars$g)
  all_lam <- sapply(x, function(fit) fit$pars$lam)
  all_sn  <- sapply(x, function(fit) fit$pars$sn)
  
  g_source <- x[[1]]$pars$g_source
  lam_source <- x[[1]]$pars$lam_source
  
  cat("OASIS AR(1) Multi-Neuron Fit Object\n")
  cat("-----------------------------\n")
  cat(sprintf("Dimensions  : %d Neurons x %d Frames\n\n", n_neurons, n_frames))
  cat("Parameters (Mean +/- SD):\n")
  fmt_stat <- function(vals) {
    if (length(vals) > 1) {
      sprintf("%.4f +/- %.4f", mean(vals, na.rm=TRUE), sd(vals, na.rm=TRUE))
    } else {
      sprintf("%.4f", vals[1])
    }
  }
  
  cat(sprintf("  g   : %s (%s)\n", fmt_stat(all_g), g_source))
  cat(sprintf("  lam : %s (%s)\n", fmt_stat(all_lam), lam_source))
  cat(sprintf("  sn  : %s (estimated)\n", fmt_stat(all_sn)))

  if (!is.null(x[[1]]$performance)) {
    all_cor_c <- sapply(x, function(fit) fit$performance$cor_c)
    all_rms_c <- sapply(x, function(fit) fit$performance$rms_c)
    all_cor_s <- sapply(x, function(fit) fit$performance$cor_s)
    
    cat("\nPerformance (Mean vs Truth):\n")
    cat(sprintf("  Corr(C): %.4f\n", mean(all_cor_c, na.rm=TRUE)))
    cat(sprintf("  RMSE(C): %.4f\n", mean(all_rms_c, na.rm=TRUE)))
    cat(sprintf("  Corr(S): %.4f\n", mean(all_cor_s, na.rm=TRUE)))
  }
  
  cat("\nObject structure: List of 'oasis_fit' objects.\n")
  cat("Usage:\n")
  cat("  x[[i]]      : Details for i-th neuron\n")
  cat("  x[[i]]$c    : Denoised signal for i-th neuron\n")
  
  invisible(x)
}